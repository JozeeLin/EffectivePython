# 第三章 类与继承

作为一门面向对象的编程语言,python提供了继承,多态,封装等各种面向对象的特性.

## 第22条 尽量用辅助类来维护程序的状态,而不要用字典和数组

> 不要使用包含字典的字典.这种多层嵌套的代码,其他程序员很难看懂,而且自己维护起来也很麻烦.
>
> 用来保存程序状态的数据结构一旦变得过于复杂,就应该将其拆解为类,以便提供更为明确的接口,并更好的封装数据.这样做也能够在接口与具体实现之间创建抽象层.

### 把嵌套结构重构为类

```python
import collections
Grade = collections.namedtuple('Grade',('score','weight'))
class Subject(object):
    def __init__(self):
        self._grades = []
        
    def report_grade(self, score, weight):
        self._grades.append(Grade(score, weight))
        
    def average_grade(self):
        total, total_weight = 0,0
        for grade in self._grades:
            total += grade.score*grade.weight
            total_weight += grade.weight
        return total/total_weight
    
class Student(object):
    def __init__(self):
        self._subjects = {}
        
    def subject(self, name):
        if name not in self._subjects:
            self._subjects[name] = Subject()
        return self._subjects[name]
    
    def average_grade(self):
        total, count = 0,0
        for subject in self._subjects.values():
            total += subject.average_grade()
            count += 1
        return total/count
    
book = Gradebook()
albert = book.student('Albert Einstein')
math = albert.subject('Math')
math.report_grade(80, 0.10)
print(albert.average_grade())
```

### 要点

- 不要使用包含其他字典的字典,也不要使用过长的元组
- 如果容器中包含简单而又不可变的数据,那么可以先使用namedtuple来表示,待稍后有需要时,再修改为完整的类
- 保存内部状态的字典如果变得比较复杂,那就应该把这些代码拆解为多个辅助类.

## 第23条: 简单的接口应该接受函数,而不是类的实例

```python
#定制defaultdict类的行为.这种数据结构允许使用者提供一个函数,以后在查询本字典时,如果里面没有待查的键,那就用这个函数为该键创建新值.

def log_missing():
    print('key added')
    return 0

current = {'green':12,'blue':3}
increments = [('red',5),('blue',17),('orange',9),]
result = defaultdict(log_missing, current)
print('Before:', dict(result))
for key, amount in increments:
    result[key] += amount
print('After:', dict(result))

## 辅助函数使用闭包作为产生默认值的挂钩函数
def increment_with_report(current, increments):
    added_count = 0
    
    def missing():
        nonlocal added_count  #Stateful closure
        added_count += 1
        return 0
    
    result = defaultdict(missing, current)
    for key, amount in increments:
        result[key] += amount
        
    return result, added_count

#使用闭包来实现保存新添加了多少个新元素这个状态信息,这个方式有点复杂;可以通过定义一个类来解决状态保存问题
counter = CountMissing()
result = defaultdict(counter.missing, current)  #Method ref

for key, amount in increments:
    result[key] += amount
assert counter.added == 2
print(result)

#定义类中的__call__函数,使得类的意图更加明确
class BetterCountMissing(object):
    def __init__(self):
        self.added = 0
        
    def __call__(self):
        self.added += 1
        return 0
    
counter = BetterCountMissing()
counter()
assert callable(counter)
```

### 要点

- 对于连接各种python组件的简单接口来说,通常应该给其直接传入函数,而不是先定义某个类,然后再传入该类的实例.
- python中的函数和方法都可以像一级类那样引用,因此,它们与其他类型的对象一样,也能够放在表达式里面.
- 通过名为_\_call\_\_的特殊方法,可以使类的实例能够像普通的python函数那样得到调用.
- 如果要用函数来保存状态,那就应该定义新的类,并令其实现\_\_call\_\_方法,而不要定义带状态的闭包.

## 第24条:以@classmethod形式的多态去通用地构建对象

> 在python中,多态,使得继承体系中的多个类都能以各自所独有的方式来实现某个方法.这些类,都满足相同的接口或继承自相同的抽象类.

```python
'''
为了实现一套mapreduce流程,我们需要定义公共基类来表示输入的数据.
'''
class InputData(object):
    '''从磁盘中读取数据'''
    def __init__(self, path):
        super().__init__()
        self.path = path
        
    def read(self):
        return open(self.path).read()
        
class Worker(object):
    def __init__(self, input_data):
        self.input_data = input_data
        self.result = None
        
    def map(self):
        raise NotImplementedError
        
    def reduce(self, other):
        self.result += other.result
        
class LineCountWorker(Worker):
    '''换行符计数器'''
    def map(self):
        data = self.input_data.read()
        self.result = data.count('\n')
        
    def reduce(self, other):
        self.result += other.result
        
'''
如何把这些组件拼接起来?
1.为目录下所有文件创建PathInputData实例
2.使用每个PathInputData实例创建LineCountWorker实例
3.执行这些worker实例
'''
def generate_inputs(data_dir):
    for name in os.listdir(data_dir):
        yield PathInputData(os.path.join(data_dir, name))
        
def create_workers(input_list):
    workers = []
    for input_data in input_list:
        workers.append(LineCountWorker(input_data))
    return workers

def execute(workers):
    threads = [Thread(target=w.map) for w in workers]
    for thread in threads: thread.start()
    for thread in threads: thread.join()
        
    first, rest = workers[0],workers[1:]
    for worker in rest:
        first.reduce(worker)
    return first.result

#最后把上面代码的片段都拼装到函数里面,执行MapReduce流程
def mapreduce(data_dir):
    inputs = generate_inputs(data_dir)
    workers = create_workers(inputs)
    return execute(workers)

'''以上写法问题:MapReduce函数不够通用.解决方案:以一种通用的方式来构建对象.在其他编程语言中,
可以通过构造器多态解决,也就是令每个InputData子类都提供特殊的构造器.然而,最佳解决方案:使用@classmethod形式的多态.'''
class GenericInputData(object):
    def read(self):
        raise NotImplementedError
    
    @classmethod
    def generate_inputs(cls, config):
        '''接受一份含有配置参数的字典;具体的GenericInputData子类则可以解读这些参数'''
        raise NotImplementedError
        
class PathInputData(GenericInputData):
    def read(self):
        return open(self.path).read()
    
    @classmethod
    def generate_inputs(cls, config):
        data_dir = config['data_dir']
        for name in os.listdir(data_dir):
            yield cls(os.path.join(data_dir, name))
            
class GenericWorker(object):
    def map(self):
        raise NotImplementedError
        
    def reduce(self, other):
        raise NotImplementedError
        
    @classmethod
    def create_workers(cls, input_class, config):
        workers = []
        for input_data in input_class.generate_inputs(config):
            workers.append(cls(input_data))
        return workers
    
class LineCountWorker(GenericWorker):
    #...
    
def mapreduce(worker_class, input_class, config):
    workers = worker_class.create_workers(input_class, config)
    return execute(workers)
#执行
with TemporaryDirectory() as tmpdir:
    write_test_files(tmpdir)
    config = {'data_dir':tmpdir}
    result = mapreduce(LineCountWorker, PathInputData, config)
```

### 要点

- 在python程序中,每个类只能有一个构造器,也就是_\_init\_\_方法
- 通过@classmethod机制,可以用一种与构造器相仿的方式来构造类的对象
- 通过类方法多态机制,我们能够以更加通用的方式来构建并拼接具体的子类

## 第25条:用super初始化父类

```python
'''子类多重继承,在子类的init方法中调用父类的init方法,父类初始化顺序不确定问题;比如菱形继承'''
class MyBaseClass(object):
    def __init__(self, value):
        self.value = value
        
class MyChildClass(MyBaseClass):
    def __init__(self, value):
        MyBaseClass.__init__(self, 5)
        
#菱形继承
class TimesFive(MyBaseClass):
    def __init__(self, value):
        MyBaseClass.__init__(self, value)
        self.value *= 5

class PlusTwo(MyBaseClass):
    def __init__(self, value):
        MyBaseClass.__init__(self, value)
        self.value += 2
        
class ThisWay(TimesFive, PlusTwo):
    def __init__(self, value):
        TimesFive.__init__(self, value)
        PlusTwo.__init__(self, value)
        
foo = ThisWay(5)
print('Should be (5*5)+2=27 but is', foo.value)
'''
输出:Should be (5*5)+2=27 but is 7
原因:MyBaseClass初始化两次
'''
```

解决方案是调用super函数,因为定义了方法解析顺序(MRO)用以解决这个问题.

```python
#菱形继承
class TimesFiveCorrect(MyBaseClass):
    def __init__(self, value):
        super(TimesFiveCorrect, self).__init__(value)
        self.value *= 5
        
class PlusTwoCorrect(MyBaseClass):
    def __init__(self, value):
        super(PlusTwoCorrect, self).__init__(value)
        self.value += 2
        
class GoodWay(TimesFiveCorrect, PlusTwoCorrect):
    def __init__(self, value):
        super(GoodWay, self).__init__(value)
        
foo = GoodWay(5)
print 'Should be 5*(5+2)=35 and is', foo.value
'''
Should be 5*(5+2)=35 and is 35
'''
#查看GoodWay类的初始化顺序
from pprint import pprint
pprint(GoodWay.mro())
```

### 要点

- python采用标准的方法解析顺序来解决超类初始化次序及钻石继承问题.
- 总是应该使用内置的super函数来初始化父类

## 第26条:只在使用Mix-in组件制作工具类时进行多重继承

> 应该避免多重继承;
>
> 若一定要利用多重继承所带类的便利及封装性,那就考虑编写mix-in类.mix-in类是一种小型的类,它只定义了其他类可能需要提供的一套附加方法,而不定义自己的实例属性,此外,它也不要求使用者调用自己的_\_init\_\_构造器.

```python
class ToDictMixin(object):
    def to_dict(self):
        return self._traverse_dict(self.__dict__)
    
	def _traverse_dict(self, instance_dict):
        output = {}
        for key, value in instance_dict.items():
            output[key] = self._traverse(key, value)
        return output
    
    def _traverse(self, key, value):
        if isinstance(value, ToDictMixin):
            return value.to_dict()
        elif isinstance(value, dict):
            return self._traverse_dict(value)
        elif isinstance(value, list):
            return [self._traverse(key, i) for i in value]
        elif hasattr(value, '__dict__'):
            return self._traverse_dict(value.__dict__)
        else:
            return value
        
#如何使用mix-in把二叉树表示为字典
class BinaryTree(ToDictMixin):
    def __init__(self, value, left=None, right=None):
        self.value = value
        self.left = left
        self.right = right
        
tree = BinaryTree(10, 
                  left=BinaryTree(7, right=BinaryTree(9)),
                  right=BinaryTree(13, left=BinaryTree(11)))
print(tree.to_dict())
```

