# 第六章 内置模块

> python采用batteries included(在标准库中提供许多使用的模块)思路来设计标准库.
>
> 

## 第42条:用functools.wraps定义函数修饰器

> python用特殊的语法来表示修饰器(decorator),这些修饰器可以用来修饰函数.对于受到封装的原函数来说,修饰器能够那个函数执行之前以及执行之后,分别运行一些附加代码.这使得开发者可以在修饰器里面访问并修改原函数的参数及返回值,以实现约束语义(enforce semantics),调试程序,注册函数等目标.

```python
'''
实现功能:打印函数被调用时所接收的参数以及该函数的返回值.
'''
def trace(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        print('%s(%r, %r)->%r' % (func.__name__, args, kwargs, result))
        return result
    return wrapper

@trace
def fibonacci(n):
    if n in (0,1):
        return n
    return (fibonacci(n-1)+fibonacci(n-2))
'''
使用修饰器效果等于先以该函数作为参数,调用修饰器,然后把修饰器所返回的结构,赋给同一作用域中与原函数同名的那个变量.
'''
fibonacci(3)
help(fibonacci)
'''
上面的实现形式存在副作用:即修饰器返回的那个函数,其名称与原来的函数名称不一样,他叫做wrapper而不是我们希望的fibonacci.对于调试器和对象序列化器等需要使用内省机制的那些工具来说,这样的行为会干扰它们的正常工作.

解决方案:使用内置的functool模块中名为wraps的辅助函数来解决.wraps本身也是修饰器,它可以帮助开发者编写其他修饰器.将wraps修饰器运用到wrapper函数之后,它就会把与内部函数相关的重要元数据全部赋值到外围函数.
'''
def trace(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        print('%s(%r, %r)->%r' % (func.__name__, args, **kwargs, result))
        return result
    return wrapper
@trace
def fibonacci(n):
    if n in (0,1):
        return n
    return (fibonacci(n-1)+fibonacci(n-2))
fibonacci(3)
help(fibonacci)
```



### 要点

- python为修饰器提供专门的语法,它使得程序在运行的时候,能够用一个函数来修改另一个函数
- 对于调试器这种依靠内省机制的工具,直接编写修饰器会引发奇怪的行为
- 内置的functools模块提供了名为wraps的修饰器,开发者在定义子集的修饰器时,应该用wraps对其做一些处理,以避免一些问题.

## 第43条: 考虑以contextlib和with语句来改写可复用的try/finally代码

> 有些代码,需要运行在特殊的情境之下,开发者可以用python语言的with语句来表达这些代码的运行时机.
>
> 比如,如果把互斥锁放在with语句之中,那就表示只有当程序持有该锁的时候,with语句块里的那些代码,才会得到运行.

```python
lock = Lock()
with lock:
    print('Lock is held')
    
#等同于以下try/finally实现的方式
lock.acquire() #锁请求
try:
    print('Lock is held') # 获得锁资源之后进入try语句块
finally:
    lock.release() #释放锁资源
    
'''
with语句更好,它免去了编写try/finally结构所需的重复代码
开发者可以用内置的contextlib模块来处理自己所编写的对象和函数,使它们能够支持with语句.
该模块提供了名为contextmanager的修饰器.
一个简单的函数,只需经过contextmanager修饰,即可用在with语句之中.


'''
def my_function():
    logging.debug('Some debug data')
    logging.error('Error log here')
    logging.debug('More debug data')
    
my_function()
```

